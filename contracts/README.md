# Groth16Verifier.sol - Smart Contract Documentation

## üìã Overview

The `Groth16Verifier.sol` contract is an auto-generated zero-knowledge Groth16 proof verifier based on the `multiplier2` circuit. It enables on-chain verification of ZK proofs generated by your Flutter application.

## üîç Main Function

```solidity
function verifyProof(
    uint[2] calldata _pA,           // Proof Point A
    uint[2][2] calldata _pB,        // Proof Point B
    uint[2] calldata _pC,           // Proof Point C
    uint[2] calldata _pubSignals    // Public signals [minAge, userAge * minAge]
) public view returns (bool)
```

### Input Parameters

1. **`_pA`**: Groth16 proof Point A (G1 coordinates)
2. **`_pB`**: Groth16 proof Point B (G2 coordinates)
3. **`_pC`**: Groth16 proof Point C (G1 coordinates)
4. **`_pubSignals`**: Array of the circuit's public signals

### Public signals for age verification

For the `multiplier2` circuit adapted for age verification:

```solidity
_pubSignals[0] = minAge          // Minimum required age (e.g., 18)
_pubSignals[1] = userAge * minAge // Multiplication result (e.g., 21 * 18 = 378)
```

## üîß Deployment

### 1. Via Remix IDE

1. Open [Remix](https://remix.ethereum.org)
2. Create a new file `Groth16Verifier.sol`
3. Paste the generated contract content
4. Compile with Solidity 0.8.x
5. Deploy on the Sepolia testnet

### 2. Cost Estimation

* **Deployment**: ~~800,000 gas (~~\$2-5 on Sepolia)
* **Read-only verification**: FREE (`view` function)
* **Verification with transaction**: ~~200,000 gas (~~\$1-3)

### 3. Network Configuration

**Sepolia Testnet** (recommended for testing)

* RPC: `https://ethereum-sepolia.publicnode.com`
* Chain ID: 11155111
* Faucet: [Sepolia Faucet](https://sepoliafaucet.com/)

## üì± Flutter Integration

### Service Configuration

```dart
// lib/services/onchain_verification_service.dart
static const String VERIFIER_CONTRACT_ADDRESS = '0xYOUR_DEPLOYED_ADDRESS';
static const String SEPOLIA_RPC = 'https://ethereum-sepolia.publicnode.com';
```

### Read-only Verification (Recommended)

```dart
Future<bool> verifyProofReadOnly(Map<String, dynamic> proofData) async {
  final result = await _web3Client.call(
    contract: _verifierContract,
    function: verifyFunction,
    params: [pA, pB, pC, pubSignals],
  );
  
  return result.first as bool;
}
```

### Proof Data Format

```dart
Map<String, dynamic> proofData = {
  'pA': ['0x...', '0x...'],           // Point A (2 elements)
  'pB': [['0x...', '0x...'], 
         ['0x...', '0x...']],         // Point B (2x2 elements)
  'pC': ['0x...', '0x...'],           // Point C (2 elements)
  'pubSignals': ['18', '378'],        // [minAge, userAge * minAge]
};
```

## üîê Verification Keys

The contract includes the hardcoded verification keys from the circuit:

```solidity
// Alpha, beta, gamma, delta (elliptic curve points)
uint256 constant alphax = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
uint256 constant alphay = 9383485363053290200918347156157836566562967994039712273449902621266178545958;

// IC points for public inputs
uint256 constant IC0x = 6819801395408938350212900248749732364821477541620635511814266536599629892365;
uint256 constant IC1x = 17882351432929302592725330552407222299541667716607588771282887857165175611387;
uint256 constant IC2x = 15838138634521468894153380932528531886891906022296654376137218419558038465083;
```

These keys are **specific** to your `multiplier2` circuit and can only verify proofs generated with the matching `.zkey` file.

## ‚ö° Optimizations

### Gas efficiency

The contract uses assembly-level optimizations to lower costs:

1. **Elliptic operations**: Uses Ethereum precompiles
2. **Field validation**: Checks all elements are within the correct finite field
3. **Pairing check**: Uses Ethereum's pairing precompile (address 0x08)

### Security

* **Input validation**: All elements are checked before use
* **Overflow protection**: Uses secure modular arithmetic
* **Read-only**: The verification function is `view` (no state changes)

## üß™ Testing and Validation

### Test with real data

```javascript
// Example test with real proofs
const proof = {
  a: ["0x...", "0x..."],
  b: [["0x...", "0x..."], ["0x...", "0x..."]],
  c: ["0x...", "0x..."]
};

const publicSignals = ["18", "378"]; // minAge=18, userAge=21

const isValid = await verifier.verifyProof(
  proof.a,
  proof.b, 
  proof.c,
  publicSignals
);
```

### Debugging

If verification fails:

1. **Check public signals**: Correct order and format
2. **Validate the proof**: Generated with the correct circuit
3. **Control types**: uint256 in hexadecimal
4. **Test locally**: Use Ganache before deployment

## üìä Monitoring

### Events (optional)

You can add events to track verifications:

```solidity
event ProofVerified(
    address indexed verifier,
    uint256 minAge,
    uint256 timestamp,
    bool success
);

function verifyProofWithEvent(/* params */) public returns (bool) {
    bool result = verifyProof(_pA, _pB, _pC, _pubSignals);
    
    emit ProofVerified(
        msg.sender,
        _pubSignals[0], // minAge
        block.timestamp,
        result
    );
    
    return result;
}
```

### Explorer Integration

Once deployed, your contract will be visible on:

* **Sepolia Etherscan**: `https://sepolia.etherscan.io/address/0xYOUR_ADDRESS`
* **Transactions**: All verifications are public
* **ABI**: Interface for contract interaction

## üöÄ Next Steps

1. **Deploy** the contract on Sepolia
2. **Update** the address in Flutter
3. **Test** the read-only verification
4. **Integrate** into the main UI
5. **Document** for EthGlobal judges

## üí° For EthGlobal Cannes

This contract demonstrates:

* **Web3 Integration**: Deployed smart contract
* **Zero-Knowledge**: On-chain ZK verification
* **Mobile-first**: Proofs generated on mobile
* **Interoperability**: Mopro + Ethereum + Flutter


